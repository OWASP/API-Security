API2:2019 Broken User Authentication
====================================

| Παράγοντες Απειλής/Φορείς Επίθεσης | Αδυναμία Ασφαλείας | Επιπτώσεις |
| - | - | - |
| Εξαρτώνται από το API : Εκμεταλλευσιμότητα **3** | Επιπολασμός **2** : Ανιχνευσιμότητα **2** | Τεχνικές **3** : Εξαρτώνται από την Επιχείρηση |
| Ο έλεγχος ταυτότητας στα API είναι ένας πολύπλοκος και μπερδεμένος μηχανισμός. Οι μηχανικοί λογισμικού και ασφάλειας ενδέχεται να έχουν λανθασμένες αντιλήψεις σχετικά με τα όρια του ελέγχου ταυτότητας και πώς να τον εφαρμόσουν σωστά. Επιπλέον, ο μηχανισμός ελέγχου ταυτότητας είναι ένας εύκολος στόχος για τους εισβολείς, καθώς είναι εκτεθειμένος σε όλους. Αυτά τα δύο σημεία καθιστούν το στοιχείο ελέγχου ταυτότητας δυνητικά ευάλωτο σε πολλά exploits. | Υπάρχουν δύο επιμέρους ζητήματα: 1. Έλλειψη μηχανισμών προστασίας: Τα τελικά σημεία API που είναι υπεύθυνα για τον έλεγχο ταυτότητας πρέπει να αντιμετωπίζονται διαφορετικά από τα κανονικά τελικά σημεία και να εφαρμόζουν επιπλέον επίπεδα προστασίας 2. Εσφαλμένη εφαρμογή του μηχανισμού: Ο μηχανισμός χρησιμοποιείται / υλοποιείται χωρίς να λαμβάνονται υπόψη  διανύσματα επίθεσης ή είναι λάθος η περίπτωση χρήσης (π.χ. ένας μηχανισμός ελέγχου ταυτότητας που έχει σχεδιαστεί για πελάτες IoT μπορεί να μην είναι η σωστή επιλογή για εφαρμογές Ιστού). | Οι εισβολείς μπορούν να αποκτήσουν τον έλεγχο των λογαριασμών άλλων χρηστών στο σύστημα, να διαβάσουν τα προσωπικά τους δεδομένα και να εκτελέσουν ευαίσθητες ενέργειες για λογαριασμό τους, όπως συναλλαγές χρημάτων και αποστολή προσωπικών μηνυμάτων. |

## Είναι το API ευάλωτο;

Τα τελικά σημεία και οι ροές ελέγχου ταυτότητας είναι στοιχεία που πρέπει να προστατεύονται. Το "Ξέχασα τον κωδικό πρόσβασης / επαναφορά κωδικού πρόσβασης" θα πρέπει να αντιμετωπίζεται με τον ίδιο τρόπο όπως και οι μηχανισμοί ελέγχου ταυτότητας.

Ένα API είναι ευάλωτο εάν:
* Επιτρέπει [credential stuffing][1] με το οποίο ο εισβολέας έχει μια λίστα με έγκυρα ονόματα χρήστη και κωδικούς πρόσβασης.
* Επιτρέπει στους εισβολείς να εκτελούν επίθεση ωμής βίας (brute force attack) στον ίδιο λογαριασμό χρήστη, χωρίς να παρουσιάζουν μηχανισμό κλειδώματος captcha/λογαριασμού.
* Επιτρέπει αδύναμους κωδικούς πρόσβασης.
* Στέλνει ευαίσθητες λεπτομέρειες ελέγχου ταυτότητας, όπως διακριτικά ταυτότητας και κωδικούς πρόσβασης στη διεύθυνση URL.
* Δεν επικυρώνει την αυθεντικότητα των διακριτικών.
* Αποδέχεται ανυπόγραφα/ασθενώς υπογεγραμμένα διακριτικά JWT (`"alg":"none"`)/δεν επικυρώνει την ημερομηνία λήξης τους.
* Χρησιμοποιεί απλό κείμενο, μη κρυπτογραφημένους ή ασθενώς κατακερματισμένους κωδικούς πρόσβασης.
* Χρησιμοποιεί αδύναμα κλειδιά κρυπτογράφησης.

## Παράδειγμα Σεναρίων Επίθεσης

## Σενάριο #1

[Credential stuffing][1] (using [lists of known usernames/passwords][2]), is a
common attack. If an application does not implement automated threat or
credential stuffing protections, the application can be used as a password
oracle (tester) to determine if the credentials are valid.

Το [Credential stuffing][1] (χρησιμοποιώντας [λίστες γνωστών ονομάτων χρήστη/κωδικών πρόσβασης][2]), είναι μια συνηθισμένη επίθεση. Εάν μια εφαρμογή δεν εφαρμόζει αυτοματοποιημένες προστασίες από απειλές ή Credential stuffing, η εφαρμογή μπορεί να χρησιμοποιηθεί ως μαντείο κωδικού πρόσβασης (ελεγκτής) για να προσδιοριστεί εάν τα διαπιστευτήρια είναι έγκυρα.

## Σενάριο #2

Ένας εισβολέας ξεκινά τη ροή εργασιών ανάκτησης κωδικού πρόσβασης εκδίδοντας ένα 
αίτημα POST στο `/api/system/verification-codes` και παρέχοντας το όνομα χρήστη 
στο σώμα του αιτήματος. Στη συνέχεια, ένα διακριτικό SMS με 6 ψηφία αποστέλλεται 
στο τηλέφωνο του θύματος. Επειδή το API δεν εφαρμόζει πολιτική περιορισμού ρυθμού, 
ο εισβολέας μπορεί να δοκιμάσει όλους τους πιθανούς συνδυασμούς χρησιμοποιώντας 
ένα σενάριο πολλαπλών νημάτων, σε σχέση με το τελικό σημείο 
`/api/system/verification-codes/{smsToken}` για να ανακαλύψει το σωστό διακριτικό 
μέσα σε λίγα λεπτά.

## Τρόπος Πρόληψης

* Βεβαιωθείτε ότι γνωρίζετε όλες τις πιθανές ροές για έλεγχο ταυτότητας στο API 
(σύνδεσμοι για κινητά/ιστό/deep links που εφαρμόζουν έλεγχο ταυτότητας με ένα κλικ/κ.λπ.)
* Ρωτήστε τους μηχανικούς σας ποιες ροές χάσατε.
* Διαβάστε σχετικά με τους μηχανισμούς ελέγχου ταυτότητας. Βεβαιωθείτε ότι καταλαβαίνετε 
τι και πώς χρησιμοποιούνται. Το OAuth δεν είναι έλεγχος ταυτότητας, ούτε και τα κλειδιά API.
* Μην ανακαλύπτετε ξανά τον τροχό στον έλεγχο ταυτότητας, τη δημιουργία διακριτικών, 
την αποθήκευση κωδικού πρόσβασης. Χρησιμοποιήστε τα πρότυπα.
* Τα τελικά σημεία ανάκτησης διαπιστευτηρίων/λήψης κωδικού πρόσβασης θα πρέπει να αντιμετωπίζονται 
ως τελικά σημεία σύνδεσης όσον αφορά την ωμή βία, τον περιορισμό του ρυθμού και τις προστασίες κλειδώματος.
* Χρησιμοποιήστε το [OWASP Authentication Cheatsheet][3].
* Όπου είναι δυνατόν, εφαρμόστε έλεγχο ταυτότητας πολλαπλών παραγόντων (multi-factor authentication).
* Εφαρμόστε μηχανισμούς κατά της ωμής βίας για τον μετριασμό του γεμίσματος διαπιστευτηρίων, της επίθεσης 
λεξικού και των επιθέσεων ωμής βίας στα τελικά σημεία ελέγχου ταυτότητας. Αυτός ο μηχανισμός θα πρέπει 
να είναι πιο αυστηρός από τον κανονικό μηχανισμό περιορισμού ρυθμών στο API σας.
* Εφαρμόστε το μηχανισμό [account lockout][4] / captcha για να αποτρέψετε την ωμή βία εναντίον συγκεκριμένων 
χρηστών. Εφαρμόστε ελέγχους αδύναμου κωδικού πρόσβασης.
* Τα κλειδιά API δεν πρέπει να χρησιμοποιούνται για έλεγχο ταυτότητας χρήστη, αλλά για [client app/project authentication][5].

## Αναφορές

### OWASP

* [OWASP Key Management Cheat Sheet][6]
* [OWASP Authentication Cheatsheet][3]
* [Credential Stuffing][1]

### Εξωτερικές

* [CWE-798: Use of Hard-coded Credentials][7]

[1]: https://www.owasp.org/index.php/Credential_stuffing
[2]: https://github.com/danielmiessler/SecLists
[3]: https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html
[4]: https://www.owasp.org/index.php/Testing_for_Weak_lock_out_mechanism_(OTG-AUTHN-003)
[5]: https://cloud.google.com/endpoints/docs/openapi/when-why-api-key
[6]: https://www.owasp.org/index.php/Key_Management_Cheat_Sheet
[7]: https://cwe.mitre.org/data/definitions/798.html
